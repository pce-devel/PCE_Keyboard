/* 
 * PCEKeybd - Adapts a USB keyboard(JP) for use with the PC Engine
 *            For Raspberry Pi Pico or other RP2040 MCU
 *
 * This code is based on the TinyUSB Host HID example from pico-SDK v1.5.0
 *
 * Modifications for PCEKeybd
 * Copyright (c) 2021,2022,2023 David Shadoff
 *
 * ------------------------------------
 *
 * The MIT License (MIT)
 *
 * Original TinyUSB example
 * Copyright (c) 2019 Ha Thach (tinyusb.org)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "bsp/board.h"
#include "tusb.h"

#include "pico/stdlib.h"
#include "pico/time.h"
#include "pico/multicore.h"

//--------------------------------------------------------------------+
// MACRO CONSTANT TYPEDEF PROTYPES
//--------------------------------------------------------------------+


#ifdef ADAFRUIT_KB2040          // if build for Adafruit KB2040 board

#define SEL_PIN         18
#define CLR_PIN         SEL_PIN + 1
#define OUTD0_PIN       26            // Note - out pins must be a consecutive 'out' group
#define OUTD1_PIN       27
#define OUTD2_PIN       28
#define OUTD3_PIN       29

#endif


extern void hid_app_task(void);

extern volatile uint8_t key_array[18];
uint32_t key_count = 0;


//
// Overall protocol for the PC Engine keyboard is:
//  byte 0: 0x02 leader byte (in this case, generated by PIO)
//  bytes 1-16: 16 bytes of keypress bytes (with bit 7 as '1')
//  byte 17: 0x02 trailer byte
//  (automatic cycle restart if CLR signal not asserted)
//  CLR restarts the cycle at byte 0 again
//
//  Note that '0' in a bit denotes that the key is pressed
//

static absolute_time_t init_time;


/*------------- MAIN -------------*/

// note that "__not_in_flash_func" functions are loaded
// and "pinned" in SRAM - not paged in/out from XIP flash
//


//
// process_signals - inner-loop processing of events:
//                   - USB polling
//                   - event processing
//                   - detection of when a PCE scan is no longer in process (reset period)
//
static void __not_in_flash_func(process_signals)(void)
{
  while (1)
  {
    // tinyusb host task
    tuh_task();


#if CFG_TUH_HID
    hid_app_task();
#endif

  }
}

//
// core1_entry - inner-loop for the second core
//             - when the "CLR" line is de-asserted, set lock flag
//               protecting the output state machine from inconsistent data
//
static void __not_in_flash_func(core1_entry)(void)
{
static bool     prev_sel;
static bool     curr_sel;
static uint8_t  curr_nybble;

  prev_sel = gpio_get(SEL_PIN);

  while (1)
  {
     curr_sel = gpio_get(SEL_PIN);

     if (gpio_get(CLR_PIN) == 1) {
        key_count = 0;
        prev_sel = curr_sel;
        continue;
     }

     if ((prev_sel == 0) && (curr_sel == 1)) {
        key_count++;
        if (key_count == 18) {
           key_count = 0;
        }
     }

     if (curr_sel == 1) {
        curr_nybble = (key_array[key_count] >> 4) & 0x0F;
     }
     else {
        curr_nybble = (key_array[key_count] & 0x0F);
     }
     gpio_put(OUTD3_PIN, (curr_nybble & 8) ? 1 : 0);
     gpio_put(OUTD2_PIN, (curr_nybble & 4) ? 1 : 0);
     gpio_put(OUTD1_PIN, (curr_nybble & 2) ? 1 : 0);
     gpio_put(OUTD0_PIN, (curr_nybble & 1) ? 1 : 0);

     prev_sel = curr_sel;
  }
}

int main(void)
{
  board_init();

  // Pause briefly for stability before starting activity

  init_time = get_absolute_time();

  printf("PC Engine Tsuushin Keyboard (Host HID) Example\r\n");

  gpio_init(SEL_PIN);
  gpio_pull_up(SEL_PIN);
  gpio_put(SEL_PIN, 1);
  gpio_set_dir(SEL_PIN, GPIO_IN);

  gpio_init(CLR_PIN);
  gpio_pull_up(CLR_PIN);
  gpio_put(CLR_PIN, 1);
  gpio_set_dir(CLR_PIN, GPIO_IN);

  gpio_init(OUTD0_PIN);
  gpio_pull_up(OUTD0_PIN);
  gpio_put(OUTD0_PIN, 1);
  gpio_set_dir(OUTD0_PIN, GPIO_OUT);

  gpio_init(OUTD1_PIN);
  gpio_pull_up(OUTD1_PIN);
  gpio_put(OUTD1_PIN, 1);
  gpio_set_dir(OUTD1_PIN, GPIO_OUT);

  gpio_init(OUTD2_PIN);
  gpio_pull_up(OUTD2_PIN);
  gpio_put(OUTD2_PIN, 1);
  gpio_set_dir(OUTD2_PIN, GPIO_OUT);

  gpio_init(OUTD3_PIN);
  gpio_pull_up(OUTD3_PIN);
  gpio_put(OUTD3_PIN, 1);
  gpio_set_dir(OUTD3_PIN, GPIO_OUT);


  tusb_init();

  multicore_launch_core1(core1_entry);

  process_signals();

  return 0;
}

